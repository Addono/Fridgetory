### This file was generated by Nexus Schema
### Do not make changes to this file directly


"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: Float
  notIn: [Float!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type Item {
  id: Int!
  product: Product!
  quantity: Float!
  unit: String!
}

input ItemCreateInput {
  createdAt: DateTime
  product: ProductCreateOneWithoutItemsInput!
  quantity: Float!
  unit: String!
}

input ItemCreateManyWithoutProductInput {
  connect: [ItemWhereUniqueInput!]
  create: [ItemCreateWithoutProductInput!]
}

input ItemCreateWithoutProductInput {
  createdAt: DateTime
  quantity: Float!
  unit: String!
}

input ItemFilter {
  every: ItemWhereInput
  none: ItemWhereInput
  some: ItemWhereInput
}

input ItemScalarWhereInput {
  AND: [ItemScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  NOT: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  productId: IntFilter
  quantity: FloatFilter
  unit: StringFilter
}

input ItemUpdateManyDataInput {
  createdAt: DateTime
  id: Int
  quantity: Float
  unit: String
}

input ItemUpdateManyWithoutProductInput {
  connect: [ItemWhereUniqueInput!]
  create: [ItemCreateWithoutProductInput!]
  delete: [ItemWhereUniqueInput!]
  deleteMany: [ItemScalarWhereInput!]
  disconnect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutProductInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  data: ItemUpdateManyDataInput!
  where: ItemScalarWhereInput!
}

input ItemUpdateWithoutProductDataInput {
  createdAt: DateTime
  id: Int
  quantity: Float
  unit: String
}

input ItemUpdateWithWhereUniqueWithoutProductInput {
  data: ItemUpdateWithoutProductDataInput!
  where: ItemWhereUniqueInput!
}

input ItemUpsertWithWhereUniqueWithoutProductInput {
  create: ItemCreateWithoutProductInput!
  update: ItemUpdateWithoutProductDataInput!
  where: ItemWhereUniqueInput!
}

input ItemWhereInput {
  AND: [ItemWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  NOT: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  product: ProductWhereInput
  productId: IntFilter
  quantity: FloatFilter
  unit: StringFilter
}

input ItemWhereUniqueInput {
  id: Int
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Mutation {
  createOneItem(data: ItemCreateInput!): Item!
  createOnePlace(data: PlaceCreateInput!): Place!
  createOneProduct(data: ProductCreateInput!): Product!
  createOneProductType(data: ProductTypeCreateInput!): ProductType!
  deleteOneItem(where: ItemWhereUniqueInput!): Item
  deleteOnePlace(where: PlaceWhereUniqueInput!): Place
  deleteOneProduct(where: ProductWhereUniqueInput!): Product
  updateOnePlace(data: PlaceUpdateInput!, where: PlaceWhereUniqueInput!): Place
  updateOneProductType(data: ProductTypeUpdateInput!, where: ProductTypeWhereUniqueInput!): ProductType
}

type Place {
  id: Int!
  name: String!
  products(after: ProductWhereUniqueInput, before: ProductWhereUniqueInput, first: Int, last: Int): [Product!]!
}

input PlaceCreateInput {
  name: String!
  products: ProductCreateManyWithoutPlaceInput
}

input PlaceCreateOneWithoutProductsInput {
  connect: PlaceWhereUniqueInput
  create: PlaceCreateWithoutProductsInput
}

input PlaceCreateWithoutProductsInput {
  name: String!
}

input PlaceUpdateInput {
  id: Int
  name: String
  products: ProductUpdateManyWithoutPlaceInput
}

input PlaceUpdateOneRequiredWithoutProductsInput {
  connect: PlaceWhereUniqueInput
  create: PlaceCreateWithoutProductsInput
  update: PlaceUpdateWithoutProductsDataInput
  upsert: PlaceUpsertWithoutProductsInput
}

input PlaceUpdateWithoutProductsDataInput {
  id: Int
  name: String
}

input PlaceUpsertWithoutProductsInput {
  create: PlaceCreateWithoutProductsInput!
  update: PlaceUpdateWithoutProductsDataInput!
}

input PlaceWhereInput {
  AND: [PlaceWhereInput!]
  id: IntFilter
  name: StringFilter
  NOT: [PlaceWhereInput!]
  OR: [PlaceWhereInput!]
  products: ProductFilter
}

input PlaceWhereUniqueInput {
  id: Int
}

type Product {
  id: Int!
  items(after: ItemWhereUniqueInput, before: ItemWhereUniqueInput, first: Int, last: Int): [Item!]!
  productType: ProductType!
}

input ProductCreateInput {
  createdAt: DateTime
  items: ItemCreateManyWithoutProductInput
  place: PlaceCreateOneWithoutProductsInput!
  productType: ProductTypeCreateOneWithoutProductInput!
}

input ProductCreateManyWithoutPlaceInput {
  connect: [ProductWhereUniqueInput!]
  create: [ProductCreateWithoutPlaceInput!]
}

input ProductCreateManyWithoutProductTypeInput {
  connect: [ProductWhereUniqueInput!]
  create: [ProductCreateWithoutProductTypeInput!]
}

input ProductCreateOneWithoutItemsInput {
  connect: ProductWhereUniqueInput
  create: ProductCreateWithoutItemsInput
}

input ProductCreateWithoutItemsInput {
  createdAt: DateTime
  place: PlaceCreateOneWithoutProductsInput!
  productType: ProductTypeCreateOneWithoutProductInput!
}

input ProductCreateWithoutPlaceInput {
  createdAt: DateTime
  items: ItemCreateManyWithoutProductInput
  productType: ProductTypeCreateOneWithoutProductInput!
}

input ProductCreateWithoutProductTypeInput {
  createdAt: DateTime
  items: ItemCreateManyWithoutProductInput
  place: PlaceCreateOneWithoutProductsInput!
}

input ProductFilter {
  every: ProductWhereInput
  none: ProductWhereInput
  some: ProductWhereInput
}

input ProductScalarWhereInput {
  AND: [ProductScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  items: ItemFilter
  NOT: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  placeId: IntFilter
  productTypeId: IntFilter
}

type ProductType {
  id: Int!
  name: String!
}

input ProductTypeCreateInput {
  name: String!
  Product: ProductCreateManyWithoutProductTypeInput
}

input ProductTypeCreateOneWithoutProductInput {
  connect: ProductTypeWhereUniqueInput
  create: ProductTypeCreateWithoutProductInput
}

input ProductTypeCreateWithoutProductInput {
  name: String!
}

input ProductTypeUpdateInput {
  id: Int
  name: String
  Product: ProductUpdateManyWithoutProductTypeInput
}

input ProductTypeUpdateOneRequiredWithoutProductInput {
  connect: ProductTypeWhereUniqueInput
  create: ProductTypeCreateWithoutProductInput
  update: ProductTypeUpdateWithoutProductDataInput
  upsert: ProductTypeUpsertWithoutProductInput
}

input ProductTypeUpdateWithoutProductDataInput {
  id: Int
  name: String
}

input ProductTypeUpsertWithoutProductInput {
  create: ProductTypeCreateWithoutProductInput!
  update: ProductTypeUpdateWithoutProductDataInput!
}

input ProductTypeWhereInput {
  AND: [ProductTypeWhereInput!]
  id: IntFilter
  name: StringFilter
  NOT: [ProductTypeWhereInput!]
  OR: [ProductTypeWhereInput!]
  Product: ProductFilter
}

input ProductTypeWhereUniqueInput {
  id: Int
  name: String
}

input ProductUpdateManyDataInput {
  createdAt: DateTime
  id: Int
}

input ProductUpdateManyWithoutPlaceInput {
  connect: [ProductWhereUniqueInput!]
  create: [ProductCreateWithoutPlaceInput!]
  delete: [ProductWhereUniqueInput!]
  deleteMany: [ProductScalarWhereInput!]
  disconnect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutPlaceInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutPlaceInput!]
}

input ProductUpdateManyWithoutProductTypeInput {
  connect: [ProductWhereUniqueInput!]
  create: [ProductCreateWithoutProductTypeInput!]
  delete: [ProductWhereUniqueInput!]
  deleteMany: [ProductScalarWhereInput!]
  disconnect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutProductTypeInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutProductTypeInput!]
}

input ProductUpdateManyWithWhereNestedInput {
  data: ProductUpdateManyDataInput!
  where: ProductScalarWhereInput!
}

input ProductUpdateWithoutPlaceDataInput {
  createdAt: DateTime
  id: Int
  items: ItemUpdateManyWithoutProductInput
  productType: ProductTypeUpdateOneRequiredWithoutProductInput
}

input ProductUpdateWithoutProductTypeDataInput {
  createdAt: DateTime
  id: Int
  items: ItemUpdateManyWithoutProductInput
  place: PlaceUpdateOneRequiredWithoutProductsInput
}

input ProductUpdateWithWhereUniqueWithoutPlaceInput {
  data: ProductUpdateWithoutPlaceDataInput!
  where: ProductWhereUniqueInput!
}

input ProductUpdateWithWhereUniqueWithoutProductTypeInput {
  data: ProductUpdateWithoutProductTypeDataInput!
  where: ProductWhereUniqueInput!
}

input ProductUpsertWithWhereUniqueWithoutPlaceInput {
  create: ProductCreateWithoutPlaceInput!
  update: ProductUpdateWithoutPlaceDataInput!
  where: ProductWhereUniqueInput!
}

input ProductUpsertWithWhereUniqueWithoutProductTypeInput {
  create: ProductCreateWithoutProductTypeInput!
  update: ProductUpdateWithoutProductTypeDataInput!
  where: ProductWhereUniqueInput!
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  items: ItemFilter
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  place: PlaceWhereInput
  placeId: IntFilter
  productType: ProductTypeWhereInput
  productTypeId: IntFilter
}

input ProductWhereUniqueInput {
  id: Int
}

type Query {
  item(where: ItemWhereUniqueInput!): Item
  items(after: ItemWhereUniqueInput, before: ItemWhereUniqueInput, first: Int, last: Int): [Item!]!
  place(where: PlaceWhereUniqueInput!): Place
  places(after: PlaceWhereUniqueInput, before: PlaceWhereUniqueInput, first: Int, last: Int): [Place!]!
  product(where: ProductWhereUniqueInput!): Product
  products(after: ProductWhereUniqueInput, before: ProductWhereUniqueInput, first: Int, last: Int): [Product!]!
  productType(where: ProductTypeWhereUniqueInput!): ProductType
  productTypes(after: ProductTypeWhereUniqueInput, before: ProductTypeWhereUniqueInput, first: Int, last: Int): [ProductType!]!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}
